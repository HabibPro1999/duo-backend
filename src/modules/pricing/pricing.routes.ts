import { requireAuth } from '@shared/middleware/auth.middleware.js';
import { getEventById } from '@events';
import {
  getEventPricing,
  updateEventPricing,
  addPricingRule,
  updatePricingRule,
  deletePricingRule,
  calculatePrice,
} from './pricing.service.js';
import {
  EventIdParamSchema,
  RuleIdParamSchema,
  UpdateEventPricingSchema,
  CreateEmbeddedRuleSchema,
  UpdateEmbeddedRuleSchema,
  CalculatePriceRequestSchema,
  type UpdateEventPricingInput,
  type CreateEmbeddedRuleInput,
  type UpdateEmbeddedRuleInput,
  type CalculatePriceRequest,
} from './pricing.schema.js';
import { z } from 'zod';
import type { AppInstance } from '@shared/types/fastify.js';

const UserRole = {
  SUPER_ADMIN: 0,
  CLIENT_ADMIN: 1,
} as const;

const FormIdParamSchema = z
  .object({
    formId: z.string().uuid(),
  })
  .strict();

// ============================================================================
// Event Pricing Routes (Protected)
// ============================================================================

export async function pricingRulesRoutes(app: AppInstance): Promise<void> {
  // All routes require authentication
  app.addHook('onRequest', requireAuth);

  // GET /api/events/:eventId/pricing - Get event pricing (includes embedded rules)
  app.get<{ Params: { eventId: string } }>(
    '/:eventId/pricing',
    {
      schema: { params: EventIdParamSchema },
    },
    async (request, reply) => {
      const { eventId } = request.params;

      // Get event to check ownership
      const event = await getEventById(eventId);
      if (!event) {
        throw app.httpErrors.notFound('Event not found');
      }

      // Check if user is super_admin or accessing their own client's event
      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === event.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden(
          'Insufficient permissions to access this event'
        );
      }

      const pricing = await getEventPricing(eventId);
      if (!pricing) {
        throw app.httpErrors.notFound('Event pricing not found');
      }

      return reply.send(pricing);
    }
  );

  // PATCH /api/events/:eventId/pricing - Update event pricing (base price, currency, and/or rules)
  app.patch<{ Params: { eventId: string }; Body: UpdateEventPricingInput }>(
    '/:eventId/pricing',
    {
      schema: { params: EventIdParamSchema, body: UpdateEventPricingSchema },
    },
    async (request, reply) => {
      const { eventId } = request.params;

      // Get event to check ownership
      const event = await getEventById(eventId);
      if (!event) {
        throw app.httpErrors.notFound('Event not found');
      }

      // Check if user is super_admin or updating their own client's event
      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === event.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden(
          'Insufficient permissions to update this event'
        );
      }

      const pricing = await updateEventPricing(eventId, request.body);
      return reply.send(pricing);
    }
  );

  // ============================================================================
  // Embedded Rule Management Routes
  // ============================================================================

  // POST /api/events/:eventId/pricing/rules - Add a pricing rule
  app.post<{ Params: { eventId: string }; Body: CreateEmbeddedRuleInput }>(
    '/:eventId/pricing/rules',
    {
      schema: { params: EventIdParamSchema, body: CreateEmbeddedRuleSchema },
    },
    async (request, reply) => {
      const { eventId } = request.params;

      // Get event to check ownership
      const event = await getEventById(eventId);
      if (!event) {
        throw app.httpErrors.notFound('Event not found');
      }

      // Check if user is super_admin or creating for their own client
      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === event.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden(
          'Insufficient permissions to create pricing rules for this event'
        );
      }

      const pricing = await addPricingRule(eventId, request.body);
      return reply.status(201).send(pricing);
    }
  );

  // PATCH /api/events/:eventId/pricing/rules/:ruleId - Update a pricing rule
  app.patch<{
    Params: { eventId: string; ruleId: string };
    Body: UpdateEmbeddedRuleInput;
  }>(
    '/:eventId/pricing/rules/:ruleId',
    {
      schema: { params: RuleIdParamSchema, body: UpdateEmbeddedRuleSchema },
    },
    async (request, reply) => {
      const { eventId, ruleId } = request.params;

      // Get event to check ownership
      const event = await getEventById(eventId);
      if (!event) {
        throw app.httpErrors.notFound('Event not found');
      }

      // Check if user is super_admin or updating their own client's event
      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === event.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden(
          'Insufficient permissions to update this pricing rule'
        );
      }

      const pricing = await updatePricingRule(eventId, ruleId, request.body);
      return reply.send(pricing);
    }
  );

  // DELETE /api/events/:eventId/pricing/rules/:ruleId - Delete a pricing rule
  app.delete<{ Params: { eventId: string; ruleId: string } }>(
    '/:eventId/pricing/rules/:ruleId',
    {
      schema: { params: RuleIdParamSchema },
    },
    async (request, reply) => {
      const { eventId, ruleId } = request.params;

      // Get event to check ownership
      const event = await getEventById(eventId);
      if (!event) {
        throw app.httpErrors.notFound('Event not found');
      }

      // Check if user is super_admin or deleting their own client's event
      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === event.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden(
          'Insufficient permissions to delete this pricing rule'
        );
      }

      await deletePricingRule(eventId, ruleId);
      return reply.status(204).send();
    }
  );
}

// ============================================================================
// Public Routes (Price Calculation)
// ============================================================================

export async function pricingPublicRoutes(app: AppInstance): Promise<void> {
  // POST /api/forms/:formId/calculate-price - Calculate price (public)
  app.post<{ Params: { formId: string }; Body: CalculatePriceRequest }>(
    '/:formId/calculate-price',
    {
      schema: { params: FormIdParamSchema, body: CalculatePriceRequestSchema },
    },
    async (request, reply) => {
      const { formId } = request.params;
      const input = request.body;

      // Get form to find event
      const form = await app.prisma.form.findUnique({
        where: { id: formId },
        select: { eventId: true },
      });

      if (!form) {
        throw app.httpErrors.notFound('Form not found');
      }

      const breakdown = await calculatePrice(form.eventId, input);
      return reply.send(breakdown);
    }
  );
}
