import { requireAuth } from '@shared/middleware/auth.middleware.js';
import { getEventById } from '@events';
import {
  createEmailTemplate,
  getEmailTemplateById,
  getEmailTemplateClientId,
  listEmailTemplates,
  updateEmailTemplate,
  deleteEmailTemplate,
  duplicateEmailTemplate,
} from './email-template.service.js';
import {
  getAvailableVariables,
  getSampleEmailContext,
  resolveVariables,
} from './email-variable.service.js';
import { sendEmail } from './email-sendgrid.service.js';
import { queueBulkEmails } from './email-queue.service.js';
import { prisma } from '@/database/client.js';
import {
  EventIdParamSchema,
  EmailTemplateIdParamSchema,
  CreateEmailTemplateSchema,
  UpdateEmailTemplateSchema,
  ListEmailTemplatesQuerySchema,
  TestSendEmailSchema,
  BulkSendEmailSchema,
  type CreateEmailTemplateInput,
  type UpdateEmailTemplateInput,
  type ListEmailTemplatesQuery,
  type TestSendEmailInput,
  type BulkSendEmailInput,
} from './email.schema.js';
import type { AppInstance } from '@shared/types/fastify.js';
import { UserRole } from '@identity';

// ============================================================================
// Protected Routes (Admin)
// ============================================================================

export async function emailRoutes(app: AppInstance): Promise<void> {
  app.addHook('onRequest', requireAuth);

  // ==========================================================================
  // EMAIL TEMPLATES
  // ==========================================================================

  // GET /api/events/:eventId/email-templates - List templates for event
  app.get<{
    Params: { eventId: string };
    Querystring: ListEmailTemplatesQuery;
  }>(
    '/:eventId/email-templates',
    {
      schema: {
        params: EventIdParamSchema,
        querystring: ListEmailTemplatesQuerySchema,
      },
    },
    async (request, reply) => {
      const { eventId } = request.params;
      const query = request.query;

      const event = await getEventById(eventId);
      if (!event) {
        throw app.httpErrors.notFound('Event not found');
      }

      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === event.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden('Insufficient permissions');
      }

      const templates = await listEmailTemplates(eventId, query);
      return reply.send(templates);
    }
  );

  // GET /api/events/:eventId/email-templates/variables - Get available variables for event
  app.get<{
    Params: { eventId: string };
  }>(
    '/:eventId/email-templates/variables',
    {
      schema: { params: EventIdParamSchema },
    },
    async (request, reply) => {
      const { eventId } = request.params;

      const event = await getEventById(eventId);
      if (!event) {
        throw app.httpErrors.notFound('Event not found');
      }

      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === event.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden('Insufficient permissions');
      }

      const variables = await getAvailableVariables(eventId);
      return reply.send(variables);
    }
  );

  // POST /api/events/:eventId/email-templates - Create template
  app.post<{
    Params: { eventId: string };
    Body: Omit<CreateEmailTemplateInput, 'eventId'>;
  }>(
    '/:eventId/email-templates',
    {
      schema: {
        params: EventIdParamSchema,
        body: CreateEmailTemplateSchema.omit({ eventId: true }),
      },
    },
    async (request, reply) => {
      const { eventId } = request.params;
      const input = request.body;

      const event = await getEventById(eventId);
      if (!event) {
        throw app.httpErrors.notFound('Event not found');
      }

      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === event.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden('Insufficient permissions');
      }

      const template = await createEmailTemplate({ ...input, eventId });
      return reply.status(201).send(template);
    }
  );

  // GET /api/events/email-templates/:templateId - Get single template
  app.get<{ Params: { templateId: string } }>(
    '/email-templates/:templateId',
    {
      schema: { params: EmailTemplateIdParamSchema },
    },
    async (request, reply) => {
      const { templateId } = request.params;

      const template = await getEmailTemplateById(templateId);
      if (!template) {
        throw app.httpErrors.notFound('Email template not found');
      }

      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === template.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden('Insufficient permissions');
      }

      return reply.send(template);
    }
  );

  // PATCH /api/events/email-templates/:templateId - Update template
  app.patch<{ Params: { templateId: string }; Body: UpdateEmailTemplateInput }>(
    '/email-templates/:templateId',
    {
      schema: {
        params: EmailTemplateIdParamSchema,
        body: UpdateEmailTemplateSchema,
      },
    },
    async (request, reply) => {
      const { templateId } = request.params;
      const input = request.body;

      const clientId = await getEmailTemplateClientId(templateId);
      if (!clientId) {
        throw app.httpErrors.notFound('Email template not found');
      }

      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden('Insufficient permissions');
      }

      const template = await updateEmailTemplate(templateId, input);
      return reply.send(template);
    }
  );

  // DELETE /api/events/email-templates/:templateId - Delete template
  app.delete<{ Params: { templateId: string } }>(
    '/email-templates/:templateId',
    {
      schema: { params: EmailTemplateIdParamSchema },
    },
    async (request, reply) => {
      const { templateId } = request.params;

      const clientId = await getEmailTemplateClientId(templateId);
      if (!clientId) {
        throw app.httpErrors.notFound('Email template not found');
      }

      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden('Insufficient permissions');
      }

      await deleteEmailTemplate(templateId);
      return reply.status(204).send();
    }
  );

  // POST /api/events/email-templates/:templateId/duplicate - Duplicate template
  app.post<{ Params: { templateId: string }; Body: { name?: string } }>(
    '/email-templates/:templateId/duplicate',
    {
      schema: { params: EmailTemplateIdParamSchema },
    },
    async (request, reply) => {
      const { templateId } = request.params;
      const { name } = request.body || {};

      const clientId = await getEmailTemplateClientId(templateId);
      if (!clientId) {
        throw app.httpErrors.notFound('Email template not found');
      }

      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden('Insufficient permissions');
      }

      const template = await duplicateEmailTemplate(templateId, name);
      return reply.status(201).send(template);
    }
  );

  // POST /api/events/email-templates/:templateId/test-send - Send test email
  app.post<{ Params: { templateId: string }; Body: TestSendEmailInput }>(
    '/email-templates/:templateId/test-send',
    {
      schema: {
        params: EmailTemplateIdParamSchema,
        body: TestSendEmailSchema,
      },
    },
    async (request, reply) => {
      const { templateId } = request.params;
      const { recipientEmail, recipientName } = request.body;

      const template = await getEmailTemplateById(templateId);
      if (!template) {
        throw app.httpErrors.notFound('Email template not found');
      }

      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === template.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden('Insufficient permissions');
      }

      // Get sample context for variable resolution
      const sampleContext = getSampleEmailContext();

      // Resolve variables in subject and HTML content
      const resolvedSubject = resolveVariables(template.subject, sampleContext);
      const resolvedHtml = resolveVariables(template.htmlContent || '', sampleContext);
      const resolvedPlainText = resolveVariables(template.plainContent || '', sampleContext);

      // Send test email
      const result = await sendEmail({
        to: recipientEmail,
        toName: recipientName,
        subject: `[TEST] ${resolvedSubject}`,
        html: resolvedHtml,
        plainText: resolvedPlainText,
        categories: ['test-email'],
      });

      if (!result.success) {
        throw app.httpErrors.badGateway(result.error || 'Failed to send test email');
      }

      return reply.send({
        success: true,
        message: `Test email sent to ${recipientEmail}`,
        messageId: result.messageId,
      });
    }
  );

  // ==========================================================================
  // BULK EMAIL SEND (Simple - no campaigns)
  // ==========================================================================

  // POST /api/events/:eventId/email-templates/:templateId/send - Send to recipients
  app.post<{
    Params: { eventId: string; templateId: string };
    Body: BulkSendEmailInput;
  }>(
    '/:eventId/email-templates/:templateId/send',
    {
      schema: {
        params: EventIdParamSchema.extend({
          templateId: EmailTemplateIdParamSchema.shape.templateId,
        }),
        body: BulkSendEmailSchema,
      },
    },
    async (request, reply) => {
      const { eventId, templateId } = request.params;
      const { registrationIds, filters } = request.body;

      // Verify event access
      const event = await getEventById(eventId);
      if (!event) {
        throw app.httpErrors.notFound('Event not found');
      }

      const isSuperAdmin = request.user!.role === UserRole.SUPER_ADMIN;
      const isOwnClient = request.user!.clientId === event.clientId;

      if (!isSuperAdmin && !isOwnClient) {
        throw app.httpErrors.forbidden('Insufficient permissions');
      }

      // Verify template exists and belongs to this event/client
      const template = await getEmailTemplateById(templateId);
      if (!template) {
        throw app.httpErrors.notFound('Email template not found');
      }

      if (template.clientId !== event.clientId) {
        throw app.httpErrors.forbidden('Template does not belong to this client');
      }

      // Get registrations based on IDs or filters
      let registrations: Array<{
        id: string;
        email: string;
        firstName: string | null;
        lastName: string | null;
      }>;

      if (registrationIds && registrationIds.length > 0) {
        // Send to specific registrations
        registrations = await prisma.registration.findMany({
          where: {
            id: { in: registrationIds },
            eventId,
          },
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        });
      } else if (filters) {
        // Send based on filters
        registrations = await prisma.registration.findMany({
          where: {
            eventId,
            ...(filters.paymentStatus && { paymentStatus: { in: filters.paymentStatus } }),
            ...(filters.accessTypeIds && filters.accessTypeIds.length > 0 && {
              accessTypeIds: { hasSome: filters.accessTypeIds },
            }),
          },
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        });
      } else {
        throw app.httpErrors.badRequest('Either registrationIds or filters must be provided');
      }

      if (registrations.length === 0) {
        return reply.send({
          success: true,
          queued: 0,
          message: 'No recipients matched the criteria',
        });
      }

      // Queue emails
      const queued = await queueBulkEmails(templateId, registrations);

      return reply.send({
        success: true,
        queued,
        message: `${queued} emails queued for sending`,
      });
    }
  );
}
